Rule1:: never give space after and before '='
Rule 2:When there is < or > sympbol then thre is  always file name and the file after > the file is always truncated
after pipe there is always command not file name
Rule 3


print 
shell echo $0 - current shell which you are working on
echo $SHELL - shell assinged by administrator
to change shell type - ksh
chsh - shnage shell permanantly
/etc/passwd- shell is there

$ stty -a
- control charactors 


cat file_name
- opened by cat
cat < file_name
- opened by shell and passed the stream to cat command


$ wc country.txt
23 36 1425 country.txt
knows the file name
$ wc < country.txt
23 36 1425
doesn't kow the file name


$ cattt < nn
ksh: nn: cannot open

0-stdin
1-stdout
2-strerr

$ cat 0<country.txt

output to stdin (0) and cat the same


$ date > f
$ > f date
$ > f echo hi hello
$ echo a > f b

no matter where you put the command the output will be the same

$ cat <f>f

Rule 2 the file name after > always truncated


$ ddate 2> f
$ cat f
ksh: ddate:  not found
$ who 2>f
output on screen if error then put to f

$ date >f
$ date>>f

append the output



$ ls -l /etc/passwd mmmm >f
mmmm not found
$ cat f
-rw-r--r--   1 root       sys         238181 Jan  4 14:03 /etc/passwd
$ ls -l /etc/passwd mmmm 2>f
-rw-r--r--   1 root       sys         238181 Jan  4 14:03 /etc/passwd

$ ls -l /etc/passwd mmmm 2>f >f5
$ cat f
mmmm not found
$ cat f5
-rw-r--r--   1 root       sys         238181 Jan  4 14:03 /etc/passwd

Error goes to same place where 1(stdin) is going
$ ls -l /etc/passwd mmmm > f 2>&1


$ ls -l /etc/passwd mmmm 2>&1 > f
mmmm not found
$ cat f
-rw-r--r--   1 root       sys         238181 Jan  4 14:03 /etc/passwd
inthis err and inp going to scerren then after that we redirected the output to f 
so err will go to screen and then output will go to f



$ date > f > f2
$ cat f
$ cat f2
Wed Feb  8 07:20:30 IST 2012

output wil go first to f then we changed to f2 so f will be truncated



-------------------------- Redirections End ----------------------------



----------Pipes------------

$ ls -l `which sed`
-r-xr-xr-x   1 bin        bin          40960 Nov 14  2000 /bin/sed
asscent graves '``'

which command executed first then gives output to ls -l

$ echo $a
date
$ a=`date`
$ echo $a
Wed Feb 8 07:33:05 IST 2012

$ ls -l $(which date)
-r-xr-xr-x   1 bin        bin          16384 Nov 14  2000 /bin/date



-----------Filters-------------

$ head -15 country.txt | cat -n | tail -6
    10  Djibouti,451442,Djibouti,1442,Africa,1977,1980,-,Franch
    11  Equatorial Guinea,474214,Malabo,74214,Africa,1991,1995,-,Franch
    12  Fiji,832494,Suva,32494,Oceania,1970,1975,-,English
    13  France,59329691,Paris,329691,Europe,486,1945,-,Franch
    14  Greece,10601527,Athens,601527,Europe,1829,1945,-,Greek
    15  Germany,82797408,Berlin,1797408,Europe,1871,1960,-,German

do not use 
cat -n country.txt head -15 | tail -6 - unnecessary cat whole file


head tail truncate files horizontally
cut vertically

cut -d ',' -f1 country.txt  first parameter
cut -d ',' -f3 country.txt   3rd parameter
cut -d ',' -f1,3 country.txt parameter 1 and 3
cut -d ',' -f1-3 country.txt parameter 1 to 3
cut -d ',' -f3- country.txt  parameter next from 3 to last


tr command- translate the charactors
$ tr 'a-z' 'A-Z' < country.txt

lower to upper

other one change '-' to '#'

$ ls -l | tr '-' '#'
total 12
#rw#r##r##   1 lsintr1    train         1425 Feb  8 06:23 country.txt
#rw#r##r##   1 lsintr1    train            0 Feb  8 07:20 f
#rw#r##r##   1 lsintr1    train           29 Feb  8 07:20 f2
#rw#r##r##   1 lsintr1    train           70 Feb  8 07:13 f5

$ ls -l | tr 'rw' 'AB'
total 12
-AB-A--A--   1 lsintA1    tAain         1425 Feb  8 06:23 countAy.txt
-AB-A--A--   1 lsintA1    tAain            0 Feb  8 07:20 f
-AB-A--A--   1 lsintA1    tAain           29 Feb  8 07:20 f2
-AB-A--A--   1 lsintA1    tAain           70 Feb  8 07:13 f5

replce r with A and w with B alone

$ echo hiiiiihiiiii | tr -s 'i'
hihi

replace consecutive occurences of i with i
$ echo hiiiiihiiiii | tr -d 'i'
hh
delete the occurences of i


print 15 from cal
$ cal
   February 2012
 S  M Tu  W Th  F  S
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29

$  cal | head -5 | tail -1 | cut -d ' ' -f4
15

$ echo `cal | head -6 | tail -2| cut -d ' ' -f4 | tr '\n' ' '`
15 22
print 15 and 22 on sme line and command promt on next line
echo to set promt on next line

we can not use this command as this command does not take input it takes  arguments
$ cal | head -6 | tail -2| cut -d ' ' -f4 | tr '\n' ' ' | echo 

$ cal | head -6 | tail -2| cut -d ' ' -f4 | tr '\n' ' ' | xargs echo
15 22
xargs - convert input from pipe convert it into arguments and geve it to command

$ echo  /etc/passwd | xargs ls -l
-rw-r--r--   1 root       sys         238181 Jan  4 14:03 /etc/passwd

sort - sort files alphaabetically
sort -r reverse sort
 sort -t ',' -k1  country.txt
 sort -t ',' -k2  country.txt - not numeric
 sort -t ',' -k2n country.txt - sort numberically using 2nd column


$ sort -t ',' -k9 country.txt

Canada,31281092,Ottawa,1281092,North America,1867,1945,-,English
Fiji,832494,Suva,32494,Oceania,1970,1975,-,English
Ireland,3797257,Dublin,797257,Europe,1921,1945,-,English
United Kingdom,57533000,London,6756000,Europe,1066,1945,-,English
United States,252177000,Washington DC,606900,North America,1776,1945,-,English

if the laguage is common then it again start form start

use this command
if we want to geve preference to 3 rd column
then start at 9 stop at 9 then again start at 3

$ sort -t ',' -k9,9 -k3 country.txt
Ireland,3797257,Dublin,797257,Europe,1921,1945,-,English
United Kingdom,57533000,London,6756000,Europe,1066,1945,-,English
Canada,31281092,Ottawa,1281092,North America,1867,1945,-,English
Fiji,832494,Suva,32494,Oceania,1970,1975,-,English
United States,252177000,Washington DC,606900,North America,1776,1945,-,English


set -o emacs
shell behaves like emacs
we can use
set -o vi


case insensitive
$ grep -i 'english' country.txt
United Kingdom,57533000,London,6756000,Europe,1066,1945,-,English
United States,252177000,Washington DC,606900,North America,1776,1945,-,English
Fiji,832494,Suva,32494,Oceania,1970,1975,-,English
Canada,31281092,Ottawa,1281092,North America,1867,1945,-,English
Ireland,3797257,Dublin,797257,Europe,1921,1945,-,English

count grep
$ grep -c 'English' country.txt
5

$ grep 'Latin' country.txt
Venezuela,19733000,Caracas,1290087,Latin America,1811,1945,-,Spanish
Argentina,36955182,Buenos Aires,2033445,Latin America,1853,1945,-,Spanish
Brazil,172860370,Brasilia,286037,0Latin America,1822,1945,-,Portuguese
Honduras,6249598,Tegucigalpa,1249598,Latin America,1821,1945,-,Spanish

find pattern as word
$ grep -w 'Latin' country.txt
Venezuela,19733000,Caracas,1290087,Latin America,1811,1945,-,Spanish
Argentina,36955182,Buenos Aires,2033445,Latin America,1853,1945,-,Spanish
Honduras,6249598,Tegucigalpa,1249598,Latin America,1821,1945,-,Spanish

$ egrep '(Span|Engl)ish' country.txt
United Kingdom,57533000,London,6756000,Europe,1066,1945,-,English
United States,252177000,Washington DC,606900,North America,1776,1945,-,English
Venezuela,19733000,Caracas,1290087,Latin America,1811,1945,-,Spanish
Argentina,36955182,Buenos Aires,2033445,Latin America,1853,1945,-,Spanish
Fiji,832494,Suva,32494,Oceania,1970,1975,-,English
Honduras,6249598,Tegucigalpa,1249598,Latin America,1821,1945,-,Spanish
Canada,31281092,Ottawa,1281092,North America,1867,1945,-,English
Ireland,3797257,Dublin,797257,Europe,1921,1945,-,English

starting with 'I'
$ egrep '^I' country.txt
India,1014003817,New Delhi,14003817,Asia,1947,1950,-,Indian
Italy,57634327,Rome,3634327,Europe,1861,1950,-,Italian
Ireland,3797257,Dublin,797257,Europe,1921,1945,-,English

ending with ian
$ egrep 'ian$' country.txt
Hungary,10138844,Budapest,1138844,Europe,1001,1945,-,Hungerian
India,1014003817,New Delhi,14003817,Asia,1947,1950,-,Indian
Italy,57634327,Rome,3634327,Europe,1861,1950,-,Italian

starting with I and followed by char. n-t
$ egrep '^I[n-t]' country.txt
India,1014003817,New Delhi,14003817,Asia,1947,1950,-,Indian
Italy,57634327,Rome,3634327,Europe,1861,1950,-,Italian
Ireland,3797257,Dublin,797257,Europe,1921,1945,-,English


cd /etc ; pwd
it will go to /etc

(cd /etc ; pwd) - still in same dir not etc
- it opens subshell

a=foo
echo $a
(a=bar) --- its subshell
echo $a --- foo

$ date && echo hi
Wed Feb  8 10:16:49 IST 2012
hi
$ date || echo hi
Wed Feb  8 10:17:20 IST 2012


$ date || echo hi
Wed Feb  8 10:17:20 IST 2012
if last command successful
$ echo $?
0
$ ddd
ksh: ddd:  not found
if last command usuccessful
$ echo $?
1


$ touch /etc/passwd || echo 'You are not root'
touch: cannot change times on /etc/passwd
You are not root


if command unsuccessful then it will print other

$ ls /etc/passwd || echo 'You are not root'
/etc/passwd


wildcard

in this * expanded first beofre the comand execute
$ echo my lucky *
my lucky country.txt f f2 f5

esacape the wildcard charactor
$ echo my lucky "*"
my lucky *
$ echo my lucky \* - escape only one characor
my lucky *
$ echo my lucky '*'
my lucky *


a=foo
echo $a
echo "$a"
foo
echo '$a'
$a
echo \$a
$a

$ read a
mayur
$ echo $a
mayur
$ read a b
mayur sabale
$ echo $a
mayur
$ echo $b
sabale
$ read a b
mayur sabale ffh lll ggg
$ echo $a
mayur
$ echo $b
sabale ffh lll ggg
$ read x< country.txt
$ echo $x
United Kingdom,57533000,London,6756000,Europe,1066,1945,-,English

it will always take first line always


$ a=5
$ b=7
$ c="$a"+"$b"
$ echo $c
5+7
$ c="$a"\+"$b"
$ echo $c
5+7
$ let c=a+b   - arithmatic operations
$ echo $c
12
$ ((c=a+b))
$ echo $c
12
$ expr $a + $b
12
$ c=`expr $a + $b`
spaces are important otherwise it will take string
$ echo $c
12

#!/bin/sh
echo "Hello World"


if ksh is not there
#!/usr/bin/env ksh
it will find the ksh inside env


-----------------------
$ ./hello1.sh fdf gfgf wwe
Hello fdf
Hello wwe
Hello
ALL: gfgf wwe
Total no of args: 2
$ cat hello1.sh
#!/bin/ksh
echo "Hello $1"
shift
echo "Hello $2"
echo "Hello $3"
echo "ALL: $*"
echo "Total no of args: $#"
-----------------------------
     1  #!/bin/ksh
     2  echo "Hello $1"
     3  shift 2
     4  echo "Hello $1"

$ ./hello1.sh foo bar car
Hello foo
Hello car

--------------------
echo "total $#"
echo "Hello $1"
shift 2
echo "Hello $1"
echo "total $#"

$ ./hello1.sh foo bar car
total 3
Hello foo
Hello car
total 1
------------------------------

shift command removes the arguments and shift those many argument position

if we want to access argument more than 10 then we need to acess using ${10}


to check equal numbers
-------------------------
$ cat tes1.sh
#!/bin/sh

if test $1 -gt $2
then
echo YES
elif test $1 -eq $2
then
 echo EQUAL
 else
 echo NO
 fi

$ ./tes1.sh 5 5
EQUAL
$ ./tes1.sh 5 7
NO
$ ./tes1.sh  5 0
YES
------------------------------------


instead of test we can use '[' just provide the spaces before and after

to check the all parameters passed or not
-----------------------
if [ $# -lt 2 ]
then
   echo "usage $0 num1 num2"
   exit
fi

$ ./tes1.sh
usage ./tes1.sh num1 num2
------------------------
cut the disk space more than 30000 then take the size
$ df | grep -w "\/tmp"
/tmp                 (/dev/vg00/lvol6     ):  3940880 blocks    228687 i-nodes

$ df | grep -w "\/tmp" | tr -s ' ' | cut -d ' ' -f6
228681

to print non printable charactors
like difference between space and tab
end of ffile '^M's


$ echo 'a           b' | cat -vet
a^I^I  b$



-------------------
Assignment
------------------
sort output of ls -l /etc using size
ls -l /etc | tr -s ' ' | cut -d ' ' -f5 | sort -n
---------------------------------------------

Output the UID of the users which is taken as input

$ cat login_test.sh
#!/bin/sh
echo "enter the user name"
read name
if grep -w $name "/etc/passwd">/dev/null
then
echo "UID is :"
grep -w $name /etc/passwd | cut -d ':' -f3
else
 echo "users not found"
fi



----------------------------------------------------------------------------
--------------
SED
-------------

$ cat m.txt
gold     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
gold     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf


$ cat khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.


$ cat khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.

$ sed '' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.


$ sed 's/Khan/Don/' khan.txt
In Xanadu did Kubla Don
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.


Igonre case
sed 's/kan/Don/i' khan.txt

Replace ',' by '#'
but in this case replaced only once in sigle line.

$ sed 's/,/#/' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph# the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.

Global. all occurences in pattern space

$ sed 's/,/#/g' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph# the sacred river# ran
Through caverns measureless to man
Down to a sunless sea.


Replace 2nd occurance only and skip 1st occurance

$ sed 's/,/#/2' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river# ran
Through caverns measureless to man
Down to a sunless sea.

$ sed 's/gold/----/' m.txt
----     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
----     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
----     0.25 1987  USA                 Constitution 5-dollar piece
----     1    1988  Canada              Maple Leaf
$ sed '2s/gold/----/' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
gold     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf

Replace 2 to 5
$ sed '2,5s/gold/----/' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf


2 to five
$ sed '2,$s/gold/----/' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
----     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
----     0.25 1987  USA                 Constitution 5-dollar piece
----     1    1988  Canada              Maple Leaf

replace gold with ---- except 2 nd line

$ sed '2!s/gold/----/' m.txt
----     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
----     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
----     0.25 1987  USA                 Constitution 5-dollar piece
----     1    1988  Canada              Maple Leaf

except 2 to 5

$ sed '2,5!s/gold/----/' m.txt
----     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
gold     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
----     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
----     0.25 1987  USA                 Constitution 5-dollar piece
----     1    1988  Canada  

if the line contains Franz then replace in this line gold with ----

if we dont know the file in which case then use tr command to translate then pipeline it to sed
otherwise use [Ff][Rr]

$ sed '/Franz/s/gold/----/' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
gold     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf


replace from Franz till PRC then it will replace
if there are more than one cobination of Franz and PRC then it will replace those
if did not find PRC then

i.e. if after PRC if there is again Franz again
it searches the PRC from next line onwards not on same line

$ sed '/Franz/,/PRC/s/gold/----/' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf

line containg Franz till 7 th line

$ sed '/Franz/,7s/gold/----/' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf

Line 2 to line containg panda

$ sed '2,/Panda/s/gold/----/' m
sed: Cannot find or open file m.
$ sed '2,/Panda/s/gold/----/' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda


select 2nd and 5th line then after 1st pattern then press enter in next line next pattern


$ sed '2s/gold/---/
> 5s/gold/---/' m.txt
gold     1    1986  USA                 American Eagle
---     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
---     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf


same as above use -e option

$ sed -e '2s/gold/---/' -e '5s/gold/****/' m.txt
gold     1    1986  USA                 American Eagle
---     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
****     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf


$ echo ibm.com| sed -e 's/ibm/amdocs/' -e 's/amdocs/google/'
google.com

supress the priting 
$ sed -n '2,/Panda/s/gold/----/' m.txt
nothing will be printed

supress default printing and print what i told you to print

$ sed -n '2,/Panda/s/gold/----/p' m.txt
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda


same as grep
$ sed -n '/Khan/p' khan.txt
In Xanadu did Kubla Khan

$ sed -n '/Khan/p' khan.txt
In Xanadu did Kubla Khan

print only 3rd line

$ sed -n '3p' khan.txt
Where Alph, the sacred river, ran


not 3rd line
$ sed -n '3!p' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Through caverns measureless to man
Down to a sunless sea.

print only 1st and 5th line
without -n

$ sed -e '1p' -e '5p' khan.txt
In Xanadu did Kubla Khan
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.
Down to a sunless sea.

print only 1st and 5th line
$ sed -n -e '1p' -e '5p' khan.txt
In Xanadu did Kubla Khan
Down to a sunless sea.
$ sed -n '/Khan/,3p' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran

not containing Khan print only lines

$ sed -n '/Khan/!p' khan.txt
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.


replace 2 to 7 and ignore 4th
$ sed '2,7{4!s/gold/---/;}' m.txt
gold     1    1986  USA                 American Eagle
---     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
---     1    1979  RSA                 Krugerrand
---     0.5  1981  RSA                 Krugerrand
---     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf

from franz to prc except 4 th line
$ sed '/Franz/,/PRC/{4!s/gold/----/;}' m.txt
gold     1    1986  USA                 American Eagle
----     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
----     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf

print lines containing Khan
$ sed -n '/Khan/p' khan.txt
In Xanadu did Kubla Khan

print lines which does not contain khan

$ sed -n '/Khan/!p' khan.txt
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.

delete lienes which does not contain khan (use without -n)
$ sed '/khan/d' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.

repalce line after Switzerland and print on next line after that line gold with ----
(name and next line phone number)
$ sed '/Switzerland/{n; s/gold/----/;}' m.txt
gold     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf

Two lines after Switzerland replace gold by ---

$ sed '/Switzerland/{n; n; s/gold/----/;}' m.txt
gold     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
gold     1    1979  RSA                 Krugerrand
----     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf

replace both line containg switzerland also next line 
$ sed '/Switzerland/{s/gold/----/;n;s/gold/----/;}' m.txt
gold     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf


same thing as above in this we are joining the line to first line
in this keep the current line in pattern spance instead of throwing them out and takes the next line in pattern space
so we need 'g' to replace as there are more than one occurances in pattern space

$ sed '/Switzerland/{N;s/gold/----/g;}' m.txt
gold     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
----     1    1984  Switzerland         ingot
----     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf
$

lines are joined with '\n'
$ sed '1{N;s/\n/---/g;};' khan.txt
In Xanadu did Kubla Khan---A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.
$ sed '1{N;N;N;s/\n/---/g;};' khan.txt
In Xanadu did Kubla Khan---A stately pleasure dome decree:---Where Alph, the sacred river, ran---Through caverns measureless to man
Down to a sunless sea.


$  echo /etc/passwd | sed 's/\/etc\/passwd/\/tmp\/foo/'
/tmp/foo

in this we are having the delimeter as '/'
anything after s is taken as delimiter
so we can delimiter

$ echo /etc/passwd | sed 's#/etc/passwd#/tmp/foo#'
/tmp/foo
Here # is delimiter

$ echo /etc/passwd | sed 's,/etc/passwd,/tmp/foo,'
/tmp/foo

here , as delimiter



-------------
awk command
------------

pettern directed scnanning and processing language

awk 'pattern {action}' foo
awk 'pattern1 {action1; action2} pattern2 {action3, action 4} foo


$ awk '{print}' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.

$ awk '{print $0}' khan.txt
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.
$  awk '{print $1}' khan.txt
In
A
Where
Through
Down

second column
$ awk '{print $2}' khan.txt
Xanadu
stately
Alph,
caverns
to

first column then 3rd column
space will come due to ','
$ awk '{print $1,$3}' khan.txt
In did
A pleasure
Where the
Through measureless
Down a

without spances
$ awk '{print $1 $3}' khan.txt
Indid
Apleasure
Wherethe
Throughmeasureless
Downa

print literally put it in double quotes
$ awk '{print $1 "Mayur" $3}' khan.txt
InMayurdid
AMayurpleasure
WhereMayurthe
ThroughMayurmeasureless
DownMayura

$  awk '{print $1,"Mayur",$3}' khan.txt
In Mayur did
A Mayur pleasure
Where Mayur the
Through Mayur measureless
Down Mayur a

on each line how many cloumns are there
$ awk '{print NF}' khan.txt
5
5
6
5
5

Print last colmn
in this $NF which is $5

$ awk '{print $NF}' khan.txt
Khan
decree:
ran
man
sea.

print second las colmn
$ awk '{print $(NF-1)}' khan.txt
Kubla
dome
river,
to
sunless

print the line numbers

$ awk '{print NR,$0}' khan.txt
1 In Xanadu did Kubla Khan
2 A stately pleasure dome decree:
3 Where Alph, the sacred river, ran
4 Through caverns measureless to man
5 Down to a sunless sea.

same as cat -n
$ cat -n khan.txt
     1  In Xanadu did Kubla Khan
     2  A stately pleasure dome decree:
     3  Where Alph, the sacred river, ran
     4  Through caverns measureless to man
     5  Down to a sunless sea.

delimiter

$ awk -F "," '{ print $1}' country.txt
United Kingdom
United States
Venezuela
Vietnam
Yemen
Argentina
Brazil
Bahrain
Cameroon
Djibouti
Equatorial Guinea
Fiji
France
Greece
Germany
Honduras
China
Canada
Hungary
India
Italy
Ireland
Japan


search for Kubla
$ awk '/Kubla/ {print}' khan.txt
In Xanadu did Kubla Khan

search for Kubla
default action print

$ awk '/Kubla/' khan.txt
In Xanadu did Kubla Khan

search for line not containg Kubla
and adefault action print
$ awk '!/Kubla/' khan.txt
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.

$ awk 'NR==3 || NR==7 {print}' m.txt
silver  10    1981  USA                 ingot
gold     0.1  1986  PRC                 Panda

$ awk 'NR==3 || NR==7 {print NR,$0}' m.txt
3 silver  10    1981  USA                 ingot
7 gold     0.1  1986  PRC                 Panda


$ awk 'NR>10 && NR<16 {print NR, $0}' country.txt
11 Equatorial Guinea,474214,Malabo,74214,Africa,1991,1995,-,Franch
12 Fiji,832494,Suva,32494,Oceania,1970,1975,-,English
13 France,59329691,Paris,329691,Europe,486,1945,-,Franch
14 Greece,10601527,Athens,601527,Europe,1829,1945,-,Greek
15 Germany,82797408,Berlin,1797408,Europe,1871,1960,-,German

print the line number increament i every time
$ awk '{print ++i,$0}' khan.txt
1 In Xanadu did Kubla Khan
2 A stately pleasure dome decree:
3 Where Alph, the sacred river, ran
4 Through caverns measureless to man
5 Down to a sunless sea.

print where 4th column as Switzerland

$ awk '$4 == "Switzerland"' m.txt
gold     1    1984  Switzerland         ingot

same as above
$ awk '$4 == "Switzerland" {print $0}' m.txt
gold     1    1984  Switzerland         ingot

where $4 contains 'Swit'
$ awk '$4 ~ /Swit/' m.txt
gold     1    1984  Switzerland         ingot

with "||" option
$ awk '$4 ~ /Swit/ || $3 == 1979' m.txt
gold     1    1984  Switzerland         ingot
gold     1    1979  RSA                 Krugerrand


print only direcories (stariting with d)
$ ls -l | awk '/^d/ {print}'
drwxrwxrwx   3 lsintr1    train           96 Jun 24  2011 2
drwxrwxrwx   4 lsintr1    train           96 Jun 30  2011 3
drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 86048
drwxr-xr-x   2 lsintr1    train         2048 Feb  8 12:33 89077
drwxr-xr-x   2 lsintr1    train         2048 Feb  9 06:17 Abhijit
drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 DINESH
drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 DINESHmkdir
drwxr-xr-x   2 lsintr1    train         2048 Feb  9 05:56 KD738P
drwxr-xr-x   2 lsintr1    train         2048 Feb  9 05:56 Prateek



$ ls -l | awk 'BEGIN { print "list of dir:"} /^d/ {print }'
list of dir:
drwxrwxrwx   3 lsintr1    train           96 Jun 24  2011 2
drwxrwxrwx   4 lsintr1    train           96 Jun 30  2011 3
drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 86048
drwxr-xr-x   2 lsintr1    train         2048 Feb  8 12:33 89077
drwxr-xr-x   2 lsintr1    train         2048 Feb  9 06:17 Abhijit
drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 DINESH
drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 DINESHmkdir
drwxr-xr-x   4 lsintr1    train         2048 Feb  9 09:59 KD738P
drwxr-xr-x   2 lsintr1    train         2048 Feb  9 05:56 Prateek

$ ls -l | awk 'BEGIN {i=100} /^d/ {print ++i}'
101
102
103
104
105
106
107
108
109
110
111
112


$ ls -l |  awk 'BEGIN {i=100} /^d/ {print ++i,$0} EBD { print "Thank You !!!"}'
101 drwxrwxrwx   3 lsintr1    train           96 Jun 24  2011 2
102 drwxrwxrwx   4 lsintr1    train           96 Jun 30  2011 3
103 drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 86048
104 drwxr-xr-x   2 lsintr1    train         2048 Feb  8 12:33 89077
105 drwxr-xr-x   2 lsintr1    train         2048 Feb  9 06:17 Abhijit
106 drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 DINESH
107 drwxr-xr-x   2 lsintr1    train           96 Feb  8 06:24 DINESHmkdir
108 drwxr-xr-x   4 lsintr1    train         2048 Feb  9 09:59 KD738P
109 drwxr-xr-x   2 lsintr1    train         2048 Feb  9 05:56 Prateek


count lines and direcotries
$ ls -l /etc/ | awk 'BEGIN {i=0;j=0}
> /^d/{i++}
> /^-/{j++}
> END {print i, j}'
34 211

sum of double Quote
$ awk -F',' '{i+=$2} END { print i }' country.txt
3.29006e+09


$ awk -F',' '$NF=="English"{i+=$2} END { print i }' country.txt
3.45621e+08

field separator can be written in BEGIN with below syntax

$ awk 'BEGIN {FS=","} $NF=="English"{i+=$2} END { print i }' country.txt
3.45621e+08

find both patterns
$ awk -F',' '$NF~/(Engl|Span)ish/{i+=$2} END { print i }' country.txt
4.08559e+08

if condition
$ awk 'BEGIN {
> if(5 > 4) { print "yes" }
> else {print "no" }
> }'
yes

for loop
$ awk 'BEGIN {
> for(i=0;i<10;i++) { print i }
> }'
0
1
2
3
4
5
6
7
8
9

while loop
$ awk 'BEGIN {i=0; while(i<=10) { print i++ } }'
0
1
2
3
4
5
6
7
8
9
10

arrays in awk
$ awk 'BEGIN { abc[0]="foo"
> abc[1]="bar"
> print abc[0]
> }'
foo

associative arrays
key-valy pair

$ awk 'BEGIN { abc["foo"]=22
> abc["bar"]="car"
> print abc["foo"]
> }'
22

> for(i in abc) { print i } }'
foo
bar

iterative for loop to traverse array till end

$ awk 'BEGIN { abc["foo"]=22
> abc["bar"]="car"
> for(i in abc) { print i, abc[i] } }'
foo 22
bar car

count of each language
cut -d',' -f9 country.txt | sort | uniq -c
$ awk -F',' '{print $NF}' country.txt | sort | uniq -c
   2 Arabic
   1 Chinese
   5 English
   4 Franch
   1 German
   1 Greek
   1 Hungerian
   1 Indian
   1 Italian
   1 Japanese
   1 Portuguese
   3 Spanish
   1 Vietnamese
---------------------------------------
first abc[English]=0
then  abc[English]=1
then  abc[Spanish]=1

so the language and count will act as value

$ awk -F',' '{abc[$NF]++} END { for(i in abc) { print i, abc[i] } }' country.txt
Indian 1
Greek 1
Arabic 2
Franch 4
Spanish 3
English 5
Italian 1
Portuguese 1
Chinese 1
German 1
Japanese 1
Vietnamese 1
Hungerian 1
---------------------------------------
$ awk -F',' '{abc[$NF]++} END { for(i in abc) { print abc[i] ":" i} }' country.txt
1:Indian
1:Greek
2:Arabic
4:Franch
3:Spanish
5:English
1:Italian
1:Portuguese
1:Chinese
1:German
1:Japanese
1:Vietnamese
1:Hungerian
-------------------------

To reverse the file with columns

$ awk -F',' ' {for (i=NF;i>0;i--) { printf "%s ", $i } printf "\n" }' country.txt

English - 1945 1066 Europe 6756000 London 57533000 United Kingdom
English - 1945 1776 North America 606900 Washington DC 252177000 United States
Spanish - 1945 1811 Latin America 1290087 Caracas 19733000 Venezuela
Vietnamese - 1977 1945 Orient 1088862 Hanoi 67589000 Vietnam
Arabic Islam 1957 1918 Asia 427150 San'a 1184300 Yemen
Spanish - 1945 1853 Latin America 2033445 Buenos Aires 36955182 Argentina
Portuguese - 1945 1822 0Latin America 286037 Brasilia 172860370 Brazil
Arabic Islamic 1977 1973 Persian Gulf 34137 Manama 634137 Bahrain
Franch - 1974 1960 Africa 421937 Yaounde 15421937 Cameroon
Franch - 1980 1977 Africa 1442 Djibouti 451442 Djibouti
Franch - 1995 1991 Africa 74214 Malabo 474214 Equatorial Guinea
English - 1975 1970 Oceania 32494 Suva 832494 Fiji
Franch - 1945 486 Europe 329691 Paris 59329691 France
Greek - 1945 1829 Europe 601527 Athens 10601527 Greece
German - 1960 1871 Europe 1797408 Berlin 82797408 Germany
Spanish - 1945 1821 Latin America 1249598 Tegucigalpa 6249598 Honduras
Chinese - 1945 -221 Asia 61832482 Beijing 1261832482 China
English - 1945 1867 North America 1281092 Ottawa 31281092 Canada
Hungerian - 1945 1001 Europe 1138844 Budapest 10138844 Hungary
Indian - 1950 1947 Asia 14003817 New Delhi 1014003817 India
Italian - 1950 1861 Europe 3634327 Rome 57634327 Italy
English - 1945 1921 Europe 797257 Dublin 3797257 Ireland
Japanese - 1955 -660 Asia 16549976 Tokio 126549976 Japan


-------------------------
$ ./checkno.sh 5 6 7
yes
$ ./checkno.sh 5 6 2
no
$ cat checkno.sh
#!/bin/sh
if [ $1 -lt $2 ] && [ $2 -lt $3 ]
then
 echo "yes"
else
 echo "no"
fi
-------------------------------
-------------
functions
------------
$ ./fun.sh
hi
bye
Return valure is 0
$ cat fun.sh
#!/bin/sh
f() {
echo hi
echo bye
}
f
echo "Return valure is $?"

return value is the return value of last command in function

we can pass arguments to function
$ cat fun.sh
#!/bin/sh
f() {
echo "1st arg is $1"
echo "2nd arg is $2"
echo "no if arg is  $#"
}
f foo bar car
echo "Return valure is $?"

$ ./fun.sh
1st arg is foo
2nd arg is bar
no if arg is  3
Return valure is 0
------------------------------
we can use condion is function
$ cat fun.sh
#!/bin/sh
f() {
echo "1st arg is $1"
echo "2nd arg is $2"
echo "no if arg is  $#"
if [[ $1 > $2 ]]
then
 return 6
else
 return 7
fi
}
f foo bar car
echo "Return valure is $?"
$ ./fun.sh
1st arg is foo
2nd arg is bar
no if arg is  3
Return valure is 6
--------------------

#!/bin/sh
. ./func1
f
f2
$ cat func1
f(){
echo i am f
}
f2(){
echo i am f2
}

$ ./fun2.sh
i am f
i am f2
$ cat fun2.sh

we can use 'source func1'
---------------------
cat - will take input 
$ cat - khan.txt
Mayur
Mayur
Sabale
Sabale
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.




-------------------------------------------------
DAY3
--------------------------------------------------
---------------
case
--------------
$ cat case1.sh
#!/bin/sh

echo 'Enter Name: '
read n
#n=echo "$n" | tr 'a-z' 'A-Z'
case "$n" in
     david) echo david Korn
            echo Author of ksh
            ;;
     brian|chet) echo Brian Fox
            echo Author of bash
            ;;
     bill) echo bill Joy
            echo Author of csh
            ;;
     *) echo i dont know this person
esac

------------------
for loop
---------------
$ cat forloop.sh
#!/bin/sh

for i in foo bar car
do
  echo "hello $i"
done
$ ./forloop.sh
hello foo
hello bar
hello car
-----------------
print user names

$ cat forloop.sh
#!/bin/sh

for i in `who | cut -d ' ' -f1`
do
  echo "hello $i"
done
$ ./forloop.sh
hello lsintr1
hello lsintr37
hello lsksht1
hello lsintr1
hello lsintr1
hello lsintr1
hello lsintr1
hello lsintr1
hello lsintr1
hello lsasd2
hello lsintr1
hello lsintr1
hello lsksht1
--------------------------
largest number

$ cat largeno.sh
#!/bin/sh
lno=$1
for i in $*
do
  if [[ $i -gt $lno ]]
  then
   lno=$i
  fi
done
echo "largest: $lno"
$ ./largeno.sh 33 55 88 12
largest: 88
-------------------
dirs : 0
files : 37
$ cat cofilles.sh
#!/bin/sh

nfiles=0
ndir=0 /etc || exit

for i in *
do
  [[ -d $i ]] && let ndir=nndir+1
  [[ -d $i ]] && let nfiles=nfiles+1
done
echo "dirs : $ndir"
echo "files : $nfiles"
--------------------------
$ ./whiloop.sh
0
1
2
3
4
5
6
7
8
9
finally value of i is : 10
$ cat whiloop.sh
#!/bin/sh
i=0
while [ $i -ne 10 ]
do
  echo $i
  let i=i+1
done
echo "finally value of i is : $i"
--------------------------------
read using file

$ cat whifile.sh
#!/bin/sh
while read a
do
  echo "----$a-----"
done < m.txt

$ ./whifile.sh
----gold     1    1986  USA                 American Eagle-----
----gold     1    1908  Austria-Hungary     Franz Josef 100 Korona-----
----silver  10    1981  USA                 ingot-----
----gold     1    1984  Switzerland         ingot-----
----gold     1    1979  RSA                 Krugerrand-----
----gold     0.5  1981  RSA                 Krugerrand-----
----gold     0.1  1986  PRC                 Panda-----
----silver   1    1986  USA                 Liberty dollar-----
----gold     0.25 1986  USA                 Liberty 5-dollar piece-----
----silver   0.5  1986  USA                 Liberty 50-cent piece-----
----silver   1    1987  USA                 Constitution dollar-----
----gold     0.25 1987  USA                 Constitution 5-dollar piece-----
----gold     1    1988  Canada              Maple Leaf-----
-----------------------------------------
read only on line
use above loop to read whole line

$ echo $m
gold 1 1986 USA American Eagle
$ cat m.txt
gold     1    1986  USA                 American Eagle
gold     1    1908  Austria-Hungary     Franz Josef 100 Korona
silver  10    1981  USA                 ingot
gold     1    1984  Switzerland         ingot
gold     1    1979  RSA                 Krugerrand
gold     0.5  1981  RSA                 Krugerrand
gold     0.1  1986  PRC                 Panda
silver   1    1986  USA                 Liberty dollar
gold     0.25 1986  USA                 Liberty 5-dollar piece
silver   0.5  1986  USA                 Liberty 50-cent piece
silver   1    1987  USA                 Constitution dollar
gold     0.25 1987  USA                 Constitution 5-dollar piece
gold     1    1988  Canada              Maple Leaf
-------------------------
$ read m n < m.txt
$ echo $m
gold
$ echo $n
1 1986 USA American Eagle

its same as
$ read a b
foo bar car
$ echo $a
foo
$ echo $b
bar car

-----------------------------
while loop can take input from pipe.
in this use above method
read single line in two parts

$ cat heluser.sh
#!/bin/sh
who |
while read a b
do
 echo " hello $a"
done


$ ./heluser.sh
 hello lsintr1
 hello lsintr37
 hello lsasd11
 hello lsksht1
 hello lsintr1
 hello lsintr1
 hello lsintr1
 hello lsintr1
 hello lsintr1
 hello lsintr1
 hello lsasd2
 hello lsintr1
 hello lsintr1
 hello lsksht1
------------------------------
Regular expressions
$ egrep '(j|g)eo?ff(e|r)(r|e)y'
geoffery
geoffery
geoffrey
geoffrey
jeffery
jeffery
jeffrey
jeffrey

$ egrep 'a[bcd]e'
abe
abe
abcde
ace
ace


$ grep 'a[^xyz]b'
axb
axyb
afb
afb

not y and z
$ egrep 'a[x^yz]b'
axb
axb
adg
ayz

$ egrep -v '^$' country.txt
search for blank lines and dont print them
---------------------------------
:q!
$ which cd
cd:      aliased to cd !*;set prompt="`uname -n`:$cwd > "
$ type cd
cd is a shell builtin.
$
------------------------
$ kill -l
 1) HUP                                                                        23) WINCH
 2) INT                                                                        24) STOP
 3) QUIT                                                                       25) TSTP
 4) ILL                                                                        26) CONT
 5) TRAP                                                                       27) TTIN
 6) IOT                                                                        28) TTOU
 7) EMT                                                                        29) URG
 8) FPE                                                                        30) LOST
 9) KILL                                                                       31) RESERVED
10) BUS                                                                        32) DIL
11) SEGV                                                                       33) XCPU
12) SYS                                                                        34) XFSZ
13) PIPE                                                                       35) bad trap
14) ALRM                                                                       36) bad trap
15) TERM                                                                       37) RTMIN
16) USR1                                                                       38) RTMIN+1
17) USR2                                                                       39) RTMIN+2
18) CHLD                                                                       40) RTMIN+3
19) PWR                                                                        41) RTMAX-3
20) VTALRM                                                                     42) RTMAX-2
21) PROF                                                                       43) RTMAX-1
22) POLL                                                                       44) RTMAX
---------------------
 ps -ef | awk 'NR==1{print} /watchdog/{print}'
-------------------------------------------

Advanced sed
hold the 2nd line in hold space
and delete from pattern space
$ cat -n khan.txt | sed '2{h;d;}'
     1  In Xanadu did Kubla Khan
     3  Where Alph, the sacred river, ran
     4  Through caverns measureless to man
     5  Down to a sunless sea.


on 4th line print 4th line as it is and get the 2nd line from hold space

copy to hold space
$ cat -n khan.txt | sed '2{h;d;}
> 4{p;g;}'
     1  In Xanadu did Kubla Khan
     3  Where Alph, the sacred river, ran
     4  Through caverns measureless to man
     2  A stately pleasure dome decree:
     5  Down to a sunless sea.
$


append to hold space
$  cat -n khan.txt | sed '2{h;d;}
> 4{H;g;}'
     1  In Xanadu did Kubla Khan
     3  Where Alph, the sacred river, ran
     2  A stately pleasure dome decree:
     4  Through caverns measureless to man
     5  Down to a sunless sea.

x-swap the contents of swap space and hold space
p-print
x-swap again

$ cat -n khan.txt | sed '2{h;d;}
> 4{x;p;x;}'
     1  In Xanadu did Kubla Khan
     3  Where Alph, the sacred river, ran
     2  A stately pleasure dome decree:
     4  Through caverns measureless to man
     5  Down to a sunless sea.
$

$ cat -n khan.txt | sed '1{h;}
> 4{p;g;}
> '
     1  In Xanadu did Kubla Khan
     2  A stately pleasure dome decree:
     3  Where Alph, the sacred river, ran
     4  Through caverns measureless to man
     1  In Xanadu did Kubla Khan
     5  Down to a sunless sea.
---------------------------------
in this command output is given to pipe
$ cat khan.txt > foo | wc -l
0
$ cat khan.txt | tee f f2
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.
$ cat f
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.
$ cat f2
In Xanadu did Kubla Khan
A stately pleasure dome decree:
Where Alph, the sacred river, ran
Through caverns measureless to man
Down to a sunless sea.
$ cat khan.txt  | tee f f2 | wc -l
5

find largest direcotry
$ ls -l | awk '{ if ($5>max) {max=45;f=$0} } END {print f}'
-rwxr-xr-x   1 lsintr1    train           98 Feb 10 06:44 whiloop.sh



search file accorind to time
create file check with newer

$ touch -t 20120200200 sam
$ find ./ -newer sam
not newer than sam
$ find ./ ! -newer sam


if we want to seach in period then
create two files with range of time and apply more newerthan and not newer than

find wordcount and then ls the files
to execute command use -exec
$ find ./ -type f -newer sam -exec wc -l {} \; -exec -ls -l {} \;
2919 ./.sh_history
8 ./bhumeet/check.ksh
find: cannot open ./2/1/1
find: cannot open ./2/1/2/1
find: cannot open ./3/1
find: cannot open ./3/2/1
5 ./prernac/f
22 ./prernac/case1
22 ./prernac/case1.sh
22 ./prernac/case2.sh
7 ./prernac/example1.sh
14 ./prernac/maxnum.sh
20 ./prernac/fil_dir.sh
10 ./prernac/while1.sh
7 ./prernac/read_file.sh
8 ./prernac/read_file1.sh

find ./ find ./ -type f -newer sam -exec echo hi \;



you can execute any command using -exec

$ find ./ -type f -exec grep -n 'India' {} \;
20:India,1014003817,New Delhi,14003817,Asia,1947,1950,-,Indian

in this file name is printed use /dev/null

$ find ./ -type f -exec grep -n 'India' {} /dev/null \;
./country.txt:20:India,1014003817,New Delhi,14003817,Asia,1947,1950,-,Indian
